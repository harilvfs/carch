var Regex;(Regex||={}).plugins=(()=>{var $=Object.defineProperty;var O=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var G=Object.prototype.hasOwnProperty;var M=(e,t)=>{for(var n in t)$(e,n,{get:t[n],enumerable:!0})},W=(e,t,n,c)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of v(t))!G.call(e,s)&&s!==n&&$(e,s,{get:()=>t[s],enumerable:!(c=O(t,s))||c.enumerable});return e};var P=e=>W($({},"__esModule",{value:!0}),e);var z={};M(z,{recursion:()=>j});var g=Object.freeze({DEFAULT:"DEFAULT",CHAR_CLASS:"CHAR_CLASS"});function C(e,t,n,c){let s=new RegExp(String.raw`${t}|(?<$skip>\[\^?|\\?.)`,"gsu"),o=[!1],u=0,r="";for(let i of e.matchAll(s)){let{0:a,groups:{$skip:l}}=i;if(!l&&(!c||c===g.DEFAULT==!u)){n instanceof Function?r+=n(i,{context:u?g.CHAR_CLASS:g.DEFAULT,negated:o[o.length-1]}):r+=n;continue}a[0]==="["?(u++,o.push(a[1]==="^")):a==="]"&&u&&(u--,o.pop()),r+=a}return r}function S(e,t,n,c){C(e,t,n,c)}function _(e,t,n=0,c){if(!new RegExp(t,"su").test(e))return null;let s=new RegExp(`${t}|(?<$skip>\\\\?.)`,"gsu");s.lastIndex=n;let o=0,u;for(;u=s.exec(e);){let{0:r,groups:{$skip:i}}=u;if(!i&&(!c||c===g.DEFAULT==!o))return u;r==="["?o++:r==="]"&&o&&o--,s.lastIndex==u.index&&s.lastIndex++}return null}function m(e,t,n){return!!_(e,t,0,n)}function F(e,t){let n=/\\?./gsu;n.lastIndex=t;let c=e.length,s=0,o=1,u;for(;u=n.exec(e);){let[r]=u;if(r==="[")s++;else if(s)r==="]"&&s--;else if(r==="(")o++;else if(r===")"&&(o--,!o)){c=u.index;break}}return e.slice(t,c)}var H=String.raw`\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`,D=String.raw`\(\?R=(?<rDepth>[^\)]+)\)|${H}`,U=String.raw`\(\?<(?![=!])(?<captureName>[^>]+)>`,d=new RegExp(String.raw`${U}|${D}|\(\?|\\?.`,"gsu"),R="Cannot use multiple overlapping recursions";function j(e){if(!new RegExp(D,"su").test(e))return e;if(m(e,String.raw`\\[1-9]`,g.DEFAULT))throw new Error("Numbered backrefs cannot be used with recursion");if(m(e,String.raw`\(\?\(DEFINE\)`,g.DEFAULT))throw new Error("DEFINE groups cannot be used with recursion");let t=new Map,n=[],c=!1,s=0,o=0,u;for(d.lastIndex=0;u=d.exec(e);){let{0:r,groups:{captureName:i,rDepth:a,gRNameOrNum:l,gRDepth:h}}=u;if(r==="[")s++;else if(s)r==="]"&&s--;else if(a){if(I(a),c)throw new Error(R);let f=e.slice(0,u.index),p=e.slice(d.lastIndex);if(m(p,D,g.DEFAULT))throw new Error(R);return L(f,p,+a,!1)}else if(l){I(h);let f=!1;for(let w of n)if(w.name===l||w.num===+l){if(f=!0,w.hasRecursedWithin)throw new Error(R);break}if(!f)throw new Error(`Recursive \\g cannot be used outside the referenced group "\\g<${l}&R=${h}>"`);let p=t.get(l),A=F(e,p),E=e.slice(p,u.index),k=A.slice(E.length+r.length),x=L(E,k,+h,!0),T=e.slice(0,p),b=e.slice(p+A.length);e=`${T}${x}${b}`,d.lastIndex+=x.length-r.length-E.length-k.length,n.forEach(w=>w.hasRecursedWithin=!0),c=!0}else if(i)o++,t.set(String(o),d.lastIndex),t.set(i,d.lastIndex),n.push({num:o,name:i});else if(r.startsWith("(")){let f=r==="(";f&&(o++,t.set(String(o),d.lastIndex)),n.push(f?{num:o}:{})}else r===")"&&n.pop()}return e}function I(e){let t=`Max depth must be integer between 2 and 100; used ${e}`;if(!/^[1-9]\d*$/.test(e))throw new Error(t);if(e=+e,e<2||e>100)throw new Error(t)}function L(e,t,n,c){let s=new Set;c&&S(e+t,U,({groups:{captureName:u}})=>{s.add(u)},g.DEFAULT);let o=n-1;return`${e}${N(`(?:${e}`,o,c?s:null)}(?:)${N(`${t})`,o,c?s:null,"backward")}${t}`}function N(e,t,n,c="forward"){let o=r=>c==="backward"?t-r+2-1:r+2,u="";for(let r=0;r<t;r++){let i=o(r);u+=C(e,String.raw`${U}|\\k<(?<backref>[^>]+)>`,({0:a,groups:{captureName:l,backref:h}})=>{if(h&&n&&!n.has(h))return a;let f=`_$${i}`;return l?`(?<${l}${f}>`:`\\k<${h}${f}>`},g.DEFAULT)}return u}return P(z);})();
//# sourceMappingURL=regex-recursion.min.js.map
