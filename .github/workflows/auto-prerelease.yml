name: Auto Pre-release

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.github/dependabot.yml'
      - '.github/workflows/auto-*.yml'
      - '.github/workflows/typos.yml'
      - '.github/workflows/shellcheck.yml'
  workflow_dispatch:
    inputs:
      custom_version:
        description: 'Custom version prefix (optional, default is date-based)'
        required: false
        type: string
      release_title:
        description: 'Custom release title (optional)'
        required: false
        type: string

permissions:
  contents: write
  pull-requests: read

jobs:
  check_for_changes:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      version: ${{ steps.version.outputs.version }}
      title: ${{ steps.version.outputs.title }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for changes since last release
        id: check
        run: |
          # Always release if manually triggered
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            SHOULD_RELEASE="true"
            echo "Manually triggered release"
          else
            # Get the last release tag
            LAST_RELEASE_TAG=$(curl -s https://api.github.com/repos/${{ github.repository }}/releases/latest | jq -r '.tag_name')
            if [[ "$LAST_RELEASE_TAG" == "null" || -z "$LAST_RELEASE_TAG" ]]; then
              SHOULD_RELEASE="true"
              echo "No previous release found, creating initial pre-release"
            else
              # Check if there are any commits between the last release and current HEAD
              COMMIT_COUNT=$(git rev-list --count $LAST_RELEASE_TAG..HEAD)
              if [[ "$COMMIT_COUNT" -gt 0 ]]; then
                SHOULD_RELEASE="true"
                echo "Found $COMMIT_COUNT new commits since $LAST_RELEASE_TAG"
              else
                SHOULD_RELEASE="false"
                echo "No new commits since $LAST_RELEASE_TAG"
              fi
            fi
          fi
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT

      - name: Generate version
        id: version
        if: steps.check.outputs.should_release == 'true'
        run: |
          # Check if a custom version was provided
          if [[ -n "${{ github.event.inputs.custom_version }}" ]]; then
            # Use custom version if provided via workflow_dispatch
            VERSION="${{ github.event.inputs.custom_version }}"
            echo "Using custom version: $VERSION"
          else
            # Format: vYYYY.MM.DD-commits.hash
            CURRENT_DATE=$(date +'%Y.%m.%d')
            SHORT_SHA=$(git rev-parse --short HEAD)
            COMMIT_COUNT=$(git rev-list --count HEAD)
            VERSION="v${CURRENT_DATE}-${COMMIT_COUNT}.${SHORT_SHA}"
            echo "Generated version: $VERSION"
          fi
          
          # Generate title
          if [[ -n "${{ github.event.inputs.release_title }}" ]]; then
            TITLE="${{ github.event.inputs.release_title }}"
          else
            TITLE="Pre-release $VERSION"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "title=$TITLE" >> $GITHUB_OUTPUT

  build_binaries:
    needs: check_for_changes
    if: needs.check_for_changes.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Install musl-tools
        run: sudo apt-get update && sudo apt-get install musl-tools
        
      - name: Cache Cargo registry
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-registry-
          
      - name: Cache Cargo index
        uses: actions/cache@v4
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-index-
          
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-unknown-linux-musl
          
      - name: Install cross-rs for cross-compilation
        run: cargo install cross
          
      - name: Build x86_64 binary
        run: cargo build --target-dir=build --release --verbose --target=x86_64-unknown-linux-musl --all-features
        
      - name: Build aarch64 binary
        run: |
          cross build --target-dir=build --release --verbose --target=aarch64-unknown-linux-musl --all-features
          mv ./build/aarch64-unknown-linux-musl/release/carch ./build/aarch64-unknown-linux-musl/release/carch-aarch64
          
      - name: Upload binaries as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: compiled-binaries
          path: |
            ./build/x86_64-unknown-linux-musl/release/carch
            ./build/aarch64-unknown-linux-musl/release/carch-aarch64
          retention-days: 1

  create_release:
    needs: [check_for_changes, build_binaries]
    if: needs.check_for_changes.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Download binaries
        uses: actions/download-artifact@v4
        with:
          name: compiled-binaries
          path: ./binaries
          
      - name: Prepare binaries for release
        run: |
          chmod +x ./binaries/carch
          chmod +x ./binaries/carch-aarch64
          ls -la ./binaries/
          
      - name: Extract commit messages
        id: commit_messages
        run: |
          # Get the last release tag
          LAST_RELEASE_TAG=$(curl -s https://api.github.com/repos/${{ github.repository }}/releases/latest | jq -r '.tag_name')
          if [[ "$LAST_RELEASE_TAG" == "null" || -z "$LAST_RELEASE_TAG" ]]; then
            # If no previous release, use the last 20 commits
            COMMITS=$(git log -20 --format="format:- %s (%h)")
          else
            # Get commits since last release
            COMMITS=$(git log $LAST_RELEASE_TAG..HEAD --format="format:- %s (%h)")
          fi
          
          # Filter out merge commits
          COMMITS=$(echo "$COMMITS" | grep -v "^- Merge")
          
          # Store raw commits for use in combined notes
          echo "RAW_COMMITS<<EOF" >> $GITHUB_ENV
          echo "$COMMITS" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
      
      - name: Generate PR Release Notes
        id: generate_notes
        uses: release-drafter/release-drafter@v6
        with:
          config-name: release-drafter.yml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Combine PR and Commit Notes
        id: combine_notes
        run: |
          # Create a temporary file with PR notes
          echo "${{ steps.generate_notes.outputs.body }}" > pr_notes.md
          
          # Extract categories from PR notes
          grep -E '## ' pr_notes.md > categories.txt || echo "No categories found in PR notes"
          
          # Process each category
          {
            echo "**Pre-release build** - Automatically generated from latest commits"
            echo ""
            echo "## ðŸ“¦ Binaries"
            echo "![Downloads x86_64](https://img.shields.io/github/downloads/harilvfs/carch/${{ needs.check_for_changes.outputs.version }}/carch?color=%235E81AC&style=for-the-badge&logoColor=85e185&labelColor=1c1c29) ![Downloads aarch64](https://img.shields.io/github/downloads/harilvfs/carch/${{ needs.check_for_changes.outputs.version }}/carch-aarch64?color=%235E81AC&style=for-the-badge&logoColor=85e185&labelColor=1c1c29)"
            echo ""
            
            # Process each known category and combine PR notes with commits
            
            # Features
            if grep -q "## ðŸš€ Features" categories.txt; then
              echo "## ðŸš€ Features"
              # Extract PR entries
              sed -n '/## ðŸš€ Features/,/^##/{/^##/!p}' pr_notes.md | grep -v '^$'
              # Add commits
              echo "${{ env.RAW_COMMITS }}" | grep -i -E '^- (feat|feature|perf|performance|enhancement)(\(.*\))?:' || true
              echo ""
            fi
            
            # Rust
            if grep -q "## ðŸ¦€ Rust" categories.txt || echo "${{ env.RAW_COMMITS }}" | grep -q -i -E '^- (rust)(\(.*\))?:'; then
              echo "## ðŸ¦€ Rust"
              # Extract PR entries
              sed -n '/## ðŸ¦€ Rust/,/^##/{/^##/!p}' pr_notes.md | grep -v '^$' || true
              # Add commits
              echo "${{ env.RAW_COMMITS }}" | grep -i -E '^- (rust)(\(.*\))?:' || true
              echo ""
            fi
            
            # Bug Fixes
            if grep -q "## ðŸ› Bug Fixes" categories.txt || echo "${{ env.RAW_COMMITS }}" | grep -q -i -E '^- (fix|bugfix|bug|fixes)(\(.*\))?:'; then
              echo "## ðŸ› Bug Fixes"
              # Extract PR entries
              sed -n '/## ðŸ› Bug Fixes/,/^##/{/^##/!p}' pr_notes.md | grep -v '^$' || true
              # Add commits
              echo "${{ env.RAW_COMMITS }}" | grep -i -E '^- (fix|bugfix|bug|fixes)(\(.*\))?:' || true
              echo ""
            fi
            
            # Refactor
            if grep -q "## ðŸ”„ Refactor" categories.txt || echo "${{ env.RAW_COMMITS }}" | grep -q -i -E '^- (refactor)(\(.*\))?:'; then
              echo "## ðŸ”„ Refactor"
              # Extract PR entries
              sed -n '/## ðŸ”„ Refactor/,/^##/{/^##/!p}' pr_notes.md | grep -v '^$' || true
              # Add commits
              echo "${{ env.RAW_COMMITS }}" | grep -i -E '^- (refactor)(\(.*\))?:' || true
              echo ""
            fi
            
            # Updates
            if grep -q "## ðŸ”¼ Updates" categories.txt || echo "${{ env.RAW_COMMITS }}" | grep -q -i -E '^- (update|updates)(\(.*\))?:'; then
              echo "## ðŸ”¼ Updates"
              # Extract PR entries
              sed -n '/## ðŸ”¼ Updates/,/^##/{/^##/!p}' pr_notes.md | grep -v '^$' || true
              # Add commits
              echo "${{ env.RAW_COMMITS }}" | grep -i -E '^- (update|updates)(\(.*\))?:' || true
              echo ""
            fi
            
            # Build
            if grep -q "## ðŸ› ï¸ Build" categories.txt || echo "${{ env.RAW_COMMITS }}" | grep -q -i -E '^- (build|dependencies|deps|chore)(\(.*\))?:'; then
              echo "## ðŸ› ï¸ Build"
              # Extract PR entries
              sed -n '/## ðŸ› ï¸ Build/,/^##/{/^##/!p}' pr_notes.md | grep -v '^$' || true
              # Add commits
              echo "${{ env.RAW_COMMITS }}" | grep -i -E '^- (build|dependencies|deps|chore)(\(.*\))?:' || true
              echo ""
            fi
            
            # Test
            if grep -q "## ðŸ§ª Test" categories.txt || echo "${{ env.RAW_COMMITS }}" | grep -q -i -E '^- (test|tests)(\(.*\))?:'; then
              echo "## ðŸ§ª Test"
              # Extract PR entries
              sed -n '/## ðŸ§ª Test/,/^##/{/^##/!p}' pr_notes.md | grep -v '^$' || true
              # Add commits
              echo "${{ env.RAW_COMMITS }}" | grep -i -E '^- (test|tests)(\(.*\))?:' || true
              echo ""
            fi
            
            # Remove
            if grep -q "## ðŸ“ Remove" categories.txt || echo "${{ env.RAW_COMMITS }}" | grep -q -i -E '^- (remove)(\(.*\))?:'; then
              echo "## ðŸ“ Remove"
              # Extract PR entries
              sed -n '/## ðŸ“ Remove/,/^##/{/^##/!p}' pr_notes.md | grep -v '^$' || true
              # Add commits
              echo "${{ env.RAW_COMMITS }}" | grep -i -E '^- (remove)(\(.*\))?:' || true
              echo ""
            fi
            
            # Custom
            if grep -q "## ðŸ”§ Custom" categories.txt || echo "${{ env.RAW_COMMITS }}" | grep -q -i -E '^- (custom)(\(.*\))?:'; then
              echo "## ðŸ”§ Custom"
              # Extract PR entries
              sed -n '/## ðŸ”§ Custom/,/^##/{/^##/!p}' pr_notes.md | grep -v '^$' || true
              # Add commits
              echo "${{ env.RAW_COMMITS }}" | grep -i -E '^- (custom)(\(.*\))?:' || true
              echo ""
            fi
            
            # UI/UX
            if grep -q "## ðŸŽ¨ UI/UX" categories.txt || echo "${{ env.RAW_COMMITS }}" | grep -q -i -E '^- (ui|ux|UI|UX)(\(.*\))?:'; then
              echo "## ðŸŽ¨ UI/UX"
              # Extract PR entries
              sed -n '/## ðŸŽ¨ UI/UX/,/^##/{/^##/!p}' pr_notes.md | grep -v '^$' || true
              # Add commits
              echo "${{ env.RAW_COMMITS }}" | grep -i -E '^- (ui|ux|UI|UX)(\(.*\))?:' || true
              echo ""
            fi
            
            # Docs
            if grep -q "## ðŸ“– Docs" categories.txt || echo "${{ env.RAW_COMMITS }}" | grep -q -i -E '^- (docs|doc|documentation)(\(.*\))?:'; then
              echo "## ðŸ“– Docs"
              # Extract PR entries
              sed -n '/## ðŸ“– Docs/,/^##/{/^##/!p}' pr_notes.md | grep -v '^$' || true
              # Add commits
              echo "${{ env.RAW_COMMITS }}" | grep -i -E '^- (docs|doc|documentation)(\(.*\))?:' || true
              echo ""
            fi
            
            # Other Changes
            if grep -q "## Other Changes" categories.txt; then
              echo "## ðŸ” Other Changes"
              # Extract PR entries
              sed -n '/## Other Changes/,/^##/{/^##/!p}' pr_notes.md | grep -v '^$' || true
              # Add other commits
              echo "${{ env.RAW_COMMITS }}" | grep -v -i -E '^- (feat|feature|perf|performance|enhancement|rust|fix|bugfix|bug|fixes|refactor|update|updates|build|dependencies|deps|chore|test|tests|remove|custom|ui|ux|UI|UX|docs|doc|documentation)(\(.*\))?:' || true
              echo ""
            fi
          } > combined_notes.md
          
          # Store combined notes
          COMBINED_NOTES=$(cat combined_notes.md)
          echo "COMBINED_NOTES<<EOF" >> $GITHUB_ENV
          echo "$COMBINED_NOTES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Create Pre-release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.check_for_changes.outputs.version }}
          name: "${{ needs.check_for_changes.outputs.title }}"
          body: |
            ${{ env.COMBINED_NOTES }}
          files: |
            ./binaries/carch
            ./binaries/carch-aarch64
          prerelease: true 